<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="TP.Service.VirtualService">
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.SOAP.GenericService</Super>
<TimeCreated>62341,81962.678718</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.SOAP.InboundAdapter</Default>
</Parameter>

<Parameter name="SETTINGS">
<Default>Validation</Default>
</Parameter>

<Method name="OnProcessInput">
<FormalSpec><![CDATA[pRequestBody:%CharacterStream,pResponseBody:%CharacterStream,&pAction:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#Dim tSC As %Status
	#Dim tException As %Exception.SystemException
	
	Set tSC = $$$OK
	
	Try {
	 	#Dim tResponse As GenericMessage

		Set pResponseBody=$$$NULLOREF
		Set tRequest=##class(TP.Message.SOAPRequest).%New(pRequestBody,,"%iaHeader",pRequestBody.GetAttribute("EnvelopeStream"),,##class(EnsLib.EDI.XML.Document).%New(..ImportHandler))
		Set tSC=..resolveAndIndex(tRequest)
		If ($$$ISERR(tSC)) { Quit }
		
		set tUrl = tRequest.HTTPHeaders.GetAt("URL")
		$$$LOGINFO(tUrl)
		
		//Get SOAP Header
		//TODO: Check which RIV-TA version
		#Dim txPath As %XML.XPATH.Document
		#Dim txPathRes As %XML.XPATH.ValueResult
		#Dim tList As %ListOfObjects
		#Dim tSoapHeaderTo As %String
		#Dim tSoapHeaderFrom As %String
		#Dim tWsaTo As %String
		#Dim tWsaFrom As %String
		
		Set tSoapHeaderTo = ""
		Set tSoapHeaderFrom = ""
		Set tWsaTo = ""
		Set tWsaFrom = ""
		Set tRequest.SOAPAction = ""
		
		//Get SOAP Action from HTTP header
		If (tRequest.HTTPHeaders.GetAt("soapaction") '= "") {
			Set tRequest.SOAPAction = $REPLACE(tRequest.HTTPHeaders.GetAt("soapaction"), $Char(34), "")
			$$$TRACE("Value from HTTP Header soapaction: " _ tRequest.SOAPAction)
		}
		
		Set tSC = ##class(%XML.XPATH.Document).CreateFromStream(tRequest.EnvelopeStream, .txPath)
		
		//Get SOAP Header To
		Set txPath.PrefixMappings = ""
		Set tSC = txPath.EvaluateExpression("/soapenv:Envelope/soapenv:Header/To", "text()", .tList)
		If (tList.Count() > 0) {
			Set txPathRes = tList.GetAt(1)
			Set tSoapHeaderTo = txPathRes.Value
			
			$$$TRACE("Value from SOAP Header To: " _ tSoapHeaderTo)
		}
		
		//Get SOAP Header From
		Set tSC = txPath.EvaluateExpression("/soapenv:Envelope/soapenv:Header/From", "text()", .tList)
		If (tList.Count() > 0) {
			Set txPathRes = tList.GetAt(1)
			Set tSoapHeaderFrom = txPathRes.Value
			
			$$$TRACE("Value from SOAP Header From " _ tSoapHeaderFrom)
		}
		
		//Get namespace
		Set txPath.PrefixMappings = "soapenv http://schemas.xmlsoap.org/soap/envelope/"
		Set tSC = txPath.EvaluateExpression("/soapenv:Envelope", "@xmlns:urn", .tList)
		set ^aa1 = tList.Count()
		If (tList.Count() > 0) {
			Set txPathRes = tList.GetAt(1)
			set ^aa2 = txPathRes.Value
			Set tRequest.SOAPNamespace = txPathRes.Value
			
			$$$TRACE("Value from SOAP Header namespace " _ tRequest.SOAPNamespace)
		}
		
		//Get WS-Addressing To SOAP Header
		Set txPath.PrefixMappings = "wsa http://www.w3.org/2005/08/addressing"
		Set tSC = txPath.EvaluateExpression("/soapenv:Envelope/soapenv:Header/wsa:To", "text()", .tList)
		If (tList.Count() > 0) {
			Set txPathRes = tList.GetAt(1)
			Set tWsaTo = txPathRes.Value
			Set tRequest.WSATo = tWsaTo
			
			$$$TRACE("Value from SOAP Header WSA-To: " _ tWsaTo)
		}
		
		//Get WS-Addressing From SOAP Header
		Set tSC = txPath.EvaluateExpression("/soapenv:Envelope/soapenv:Header/wsa:From/wsa:Address", "text()", .tList)
		If (tList.Count() > 0) {
			Set txPathRes = tList.GetAt(1)
			Set tWsaFrom = txPathRes.Value
			Set tRequest.WSAFrom = tWsaFrom
			
			$$$TRACE("Value from SOAP Header WSA-From: " _ tWsaFrom)
		}
		
		//Get WS-Addressing SOAP action
		Set tSC = txPath.EvaluateExpression("/soapenv:Envelope/soapenv:Header/wsa:Action", "text()", .tList)
		If (tList.Count() > 0) {
			Set txPathRes = tList.GetAt(1)
			Set tRequest.SOAPAction = txPathRes.Value
			
			$$$TRACE("Value from SOAP Header WSA-Action: " _ tRequest.SOAPAction)
		}
		
		//If WSA-To existed, use that for routing, otherwise old SOAP Header To field
		If (tWsaTo '= "") {
			Set tRequest.To = tWsaTo
		}
		Else {
			Set tRequest.To = tSoapHeaderTo
		}
		
		//If WSA-From existed, use that for routing, otherwise old SOAP Header From field
		If (tWsaFrom '= "") {
			Set tRequest.From = tWsaFrom
		}
		Else {
			Set tRequest.From = tSoapHeaderFrom
		}
		
		If (..OneWay) {
			Set tSC = ..SendRequestAsync(..TargetConfigName,tRequest)
			Quit
		}
		
		Set tSC=..SendRequestSync(..TargetConfigName,tRequest,.tResponse)
		If ($$$ISERR(tSC)) { Quit }
		
		#; Adapter will reassemble response stream from message envelope/header and body streams; here we prepare the streams
		If $IsObject(tResponse.EnvelopeDoc) && ('$IsObject(tResponse.EnvelopeStream) || 'tResponse.EnvelopeStream.Size) {
			Set tEnvelopeStream=##class(%GlobalBinaryStream).%New()
			Set tSC=tResponse.EnvelopeDoc.OutputToLibraryStream(tEnvelopeStream,..%VDocFormat)
			Do:$$$ISERR(tSC) ..ReturnMethodStatusFault(tSC)
		} Else {
			Set tEnvelopeStream=tResponse.EnvelopeStream
		}
		If $IsObject(tResponse.Doc) && ('$IsObject(tResponse.Stream) || 'tResponse.Stream.Size) {
			Set pResponseBody=##class(%GlobalCharacterStream).%New()
			Set tSC=tResponse.EnvelopeDoc.OutputToLibraryStream(pResponseBody,..%VDocFormat)
			Do:$$$ISERR(tSC) ..ReturnMethodStatusFault(tSC)
		} Else {
			Set pResponseBody=tResponse.Stream
			Set:'$IsObject(pResponseBody) pResponseBody=##class(%GlobalCharacterStream).%New()
		}
		If ""'=tEnvelopeStream { Set pResponseBody.Attributes("EnvelopeStream")=tEnvelopeStream }
		Else { Set tEnvelopeStream=pResponseBody } ; just to attach headers to

		#; Pass along Status line and selected response HTTP headers
		Set tSL="",tDoNotPassThrough=","_$ZCVT(..%ExcludeResponseHttpHeaders,"L")_",content-length,"
		Set tHeaderKey="" For { Set tHeaderKey=tResponse.HTTPHeaders.Next(tHeaderKey)  Quit:""=tHeaderKey  Set tHeaderLwr=$ZCVT(tHeaderKey,"L")
			Set:tDoNotPassThrough'[(","_tHeaderLwr_",") tEnvelopeStream.Attributes("HttpHeaders",tHeaderKey)=tResponse.HTTPHeaders.GetAt(tHeaderKey) ; no need to handle multiple on one line
			Set:tHeaderLwr="statusline" tSL=tResponse.HTTPHeaders.GetAt(tHeaderKey)
		}
		Set:tDoNotPassThrough'["statusline" tEnvelopeStream.Attributes("StatusLine")=tSL
	}
	Catch tException {
		Set tSC = tException.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnValidate">
<Description>
Override this method to implement your own custom method for validating an incoming Document
Return non-zero to prevent default validation of the message (if any);</Description>
<FormalSpec>pMsg:EnsLib.SOAP.GenericMessage,pValSpec:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If (..Validation = "WSDL") {
		
	}
	ElseIf (..Validation = "Body") {
		
	}
	
	Quit 0
]]></Implementation>
</Method>
</Class>
</Export>
